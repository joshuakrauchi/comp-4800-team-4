{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/interaction/Snap\n */\n\n\nimport CollectionEventType from '../CollectionEventType.js';\nimport EventType from '../events/EventType.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport PointerInteraction from './Pointer.js';\nimport RBush from '../structs/RBush.js';\nimport VectorEventType from '../source/VectorEventType.js';\nimport { FALSE, TRUE } from '../functions.js';\nimport { boundingExtent, createEmpty } from '../extent.js';\nimport { closestOnCircle, closestOnSegment, squaredDistance } from '../coordinate.js';\nimport { fromCircle } from '../geom/Polygon.js';\nimport { fromUserCoordinate, getUserProjection, toUserCoordinate } from '../proj.js';\nimport { getUid } from '../util.js';\nimport { getValues } from '../obj.js';\nimport { listen, unlistenByKey } from '../events.js';\n/**\n * @typedef {Object} Result\n * @property {import(\"../coordinate.js\").Coordinate|null} vertex Vertex.\n * @property {import(\"../pixel.js\").Pixel|null} vertexPixel VertexPixel.\n */\n\n/**\n * @typedef {Object} SegmentData\n * @property {import(\"../Feature.js\").default} feature Feature.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} segment Segment.\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../Collection.js\").default<import(\"../Feature.js\").default>} [features] Snap to these features. Either this option or source should be provided.\n * @property {boolean} [edge=true] Snap to edges.\n * @property {boolean} [vertex=true] Snap to vertices.\n * @property {number} [pixelTolerance=10] Pixel tolerance for considering the pointer close enough to a segment or\n * vertex for snapping.\n * @property {import(\"../source/Vector.js\").default} [source] Snap to features from this source. Either this option or features should be provided\n */\n\n/**\n * @param  {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n * @return {import(\"../Feature.js\").default} Feature.\n */\n\nfunction getFeatureFromEvent(evt) {\n  if (\n  /** @type {import(\"../source/Vector.js\").VectorSourceEvent} */\n  evt.feature) {\n    return (\n      /** @type {import(\"../source/Vector.js\").VectorSourceEvent} */\n      evt.feature\n    );\n  } else if (\n  /** @type {import(\"../Collection.js\").CollectionEvent} */\n  evt.element) {\n    return (\n      /** @type {import(\"../Feature.js\").default} */\n\n      /** @type {import(\"../Collection.js\").CollectionEvent} */\n      evt.element\n    );\n  }\n}\n\nvar tempSegment = [];\n/**\n * @classdesc\n * Handles snapping of vector features while modifying or drawing them.  The\n * features can come from a {@link module:ol/source/Vector~VectorSource} or {@link module:ol/Collection~Collection}\n * Any interaction object that allows the user to interact\n * with the features using the mouse can benefit from the snapping, as long\n * as it is added before.\n *\n * The snap interaction modifies map browser event `coordinate` and `pixel`\n * properties to force the snap to occur to any interaction that them.\n *\n * Example:\n *\n *     import Snap from 'ol/interaction/Snap';\n *\n *     const snap = new Snap({\n *       source: source\n *     });\n *\n *     map.addInteraction(snap);\n *\n * @api\n */\n\nvar Snap =\n/** @class */\nfunction (_super) {\n  __extends(Snap, _super);\n  /**\n   * @param {Options} [opt_options] Options.\n   */\n\n\n  function Snap(opt_options) {\n    var _this = this;\n\n    var options = opt_options ? opt_options : {};\n    var pointerOptions =\n    /** @type {import(\"./Pointer.js\").Options} */\n    options;\n\n    if (!pointerOptions.handleDownEvent) {\n      pointerOptions.handleDownEvent = TRUE;\n    }\n\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n\n    _this = _super.call(this, pointerOptions) || this;\n    /**\n     * @type {import(\"../source/Vector.js\").default|null}\n     * @private\n     */\n\n    _this.source_ = options.source ? options.source : null;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    _this.vertex_ = options.vertex !== undefined ? options.vertex : true;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    _this.edge_ = options.edge !== undefined ? options.edge : true;\n    /**\n     * @type {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|null}\n     * @private\n     */\n\n    _this.features_ = options.features ? options.features : null;\n    /**\n     * @type {Array<import(\"../events.js\").EventsKey>}\n     * @private\n     */\n\n    _this.featuresListenerKeys_ = [];\n    /**\n     * @type {Object<string, import(\"../events.js\").EventsKey>}\n     * @private\n     */\n\n    _this.featureChangeListenerKeys_ = {};\n    /**\n     * Extents are preserved so indexed segment can be quickly removed\n     * when its feature geometry changes\n     * @type {Object<string, import(\"../extent.js\").Extent>}\n     * @private\n     */\n\n    _this.indexedFeaturesExtents_ = {};\n    /**\n     * If a feature geometry changes while a pointer drag|move event occurs, the\n     * feature doesn't get updated right away.  It will be at the next 'pointerup'\n     * event fired.\n     * @type {!Object<string, import(\"../Feature.js\").default>}\n     * @private\n     */\n\n    _this.pendingFeatures_ = {};\n    /**\n     * @type {number}\n     * @private\n     */\n\n    _this.pixelTolerance_ = options.pixelTolerance !== undefined ? options.pixelTolerance : 10;\n    /**\n     * Segment RTree for each layer\n     * @type {import(\"../structs/RBush.js\").default<SegmentData>}\n     * @private\n     */\n\n    _this.rBush_ = new RBush();\n    /**\n     * @const\n     * @private\n     * @type {Object<string, function(Array<Array<import('../coordinate.js').Coordinate>>, import(\"../geom/Geometry.js\").default): void>}\n     */\n\n    _this.GEOMETRY_SEGMENTERS_ = {\n      'Point': _this.segmentPointGemetry_.bind(_this),\n      'LineString': _this.segmentLineStringGemetry_.bind(_this),\n      'LinearRing': _this.segmentLineStringGemetry_.bind(_this),\n      'Polygon': _this.segmentPolygonGemetry_.bind(_this),\n      'MultiPoint': _this.segmentMultiPointGemetry_.bind(_this),\n      'MultiLineString': _this.segmentMultiLineStringGemetry_.bind(_this),\n      'MultiPolygon': _this.segmentMultiPolygonGemetry_.bind(_this),\n      'GeometryCollection': _this.segmentGeometryCollectionGemetry_.bind(_this),\n      'Circle': _this.segmentCircleGemetry_.bind(_this)\n    };\n    return _this;\n  }\n  /**\n   * Add a feature to the collection of features that we may snap to.\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {boolean} [opt_listen] Whether to listen to the feature change or not\n   *     Defaults to `true`.\n   * @api\n   */\n\n\n  Snap.prototype.addFeature = function (feature, opt_listen) {\n    var register = opt_listen !== undefined ? opt_listen : true;\n    var feature_uid = getUid(feature);\n    var geometry = feature.getGeometry();\n\n    if (geometry) {\n      var segmenter = this.GEOMETRY_SEGMENTERS_[geometry.getType()];\n\n      if (segmenter) {\n        this.indexedFeaturesExtents_[feature_uid] = geometry.getExtent(createEmpty());\n        var segments =\n        /** @type {Array<Array<import('../coordinate.js').Coordinate>>} */\n        [];\n        segmenter(segments, geometry);\n\n        if (segments.length === 1) {\n          this.rBush_.insert(boundingExtent(segments[0]), {\n            feature: feature,\n            segment: segments[0]\n          });\n        } else if (segments.length > 1) {\n          var extents = segments.map(function (s) {\n            return boundingExtent(s);\n          });\n          var segmentsData = segments.map(function (segment) {\n            return {\n              feature: feature,\n              segment: segment\n            };\n          });\n          this.rBush_.load(extents, segmentsData);\n        }\n      }\n    }\n\n    if (register) {\n      this.featureChangeListenerKeys_[feature_uid] = listen(feature, EventType.CHANGE, this.handleFeatureChange_, this);\n    }\n  };\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @private\n   */\n\n\n  Snap.prototype.forEachFeatureAdd_ = function (feature) {\n    this.addFeature(feature);\n  };\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @private\n   */\n\n\n  Snap.prototype.forEachFeatureRemove_ = function (feature) {\n    this.removeFeature(feature);\n  };\n  /**\n   * @return {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|Array<import(\"../Feature.js\").default>} Features.\n   * @private\n   */\n\n\n  Snap.prototype.getFeatures_ = function () {\n    var features;\n\n    if (this.features_) {\n      features = this.features_;\n    } else if (this.source_) {\n      features = this.source_.getFeatures();\n    }\n\n    return features;\n  };\n  /**\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   */\n\n\n  Snap.prototype.handleEvent = function (evt) {\n    var result = this.snapTo(evt.pixel, evt.coordinate, evt.map);\n\n    if (result) {\n      evt.coordinate = result.vertex.slice(0, 2);\n      evt.pixel = result.vertexPixel;\n    }\n\n    return _super.prototype.handleEvent.call(this, evt);\n  };\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n   * @private\n   */\n\n\n  Snap.prototype.handleFeatureAdd_ = function (evt) {\n    var feature = getFeatureFromEvent(evt);\n    this.addFeature(feature);\n  };\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n   * @private\n   */\n\n\n  Snap.prototype.handleFeatureRemove_ = function (evt) {\n    var feature = getFeatureFromEvent(evt);\n    this.removeFeature(feature);\n  };\n  /**\n   * @param {import(\"../events/Event.js\").default} evt Event.\n   * @private\n   */\n\n\n  Snap.prototype.handleFeatureChange_ = function (evt) {\n    var feature =\n    /** @type {import(\"../Feature.js\").default} */\n    evt.target;\n\n    if (this.handlingDownUpSequence) {\n      var uid = getUid(feature);\n\n      if (!(uid in this.pendingFeatures_)) {\n        this.pendingFeatures_[uid] = feature;\n      }\n    } else {\n      this.updateFeature_(feature);\n    }\n  };\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Event.\n   * @return {boolean} If the event was consumed.\n   */\n\n\n  Snap.prototype.handleUpEvent = function (evt) {\n    var featuresToUpdate = getValues(this.pendingFeatures_);\n\n    if (featuresToUpdate.length) {\n      featuresToUpdate.forEach(this.updateFeature_.bind(this));\n      this.pendingFeatures_ = {};\n    }\n\n    return false;\n  };\n  /**\n   * Remove a feature from the collection of features that we may snap to.\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {boolean} [opt_unlisten] Whether to unlisten to the feature change\n   *     or not. Defaults to `true`.\n   * @api\n   */\n\n\n  Snap.prototype.removeFeature = function (feature, opt_unlisten) {\n    var unregister = opt_unlisten !== undefined ? opt_unlisten : true;\n    var feature_uid = getUid(feature);\n    var extent = this.indexedFeaturesExtents_[feature_uid];\n\n    if (extent) {\n      var rBush = this.rBush_;\n      var nodesToRemove_1 = [];\n      rBush.forEachInExtent(extent, function (node) {\n        if (feature === node.feature) {\n          nodesToRemove_1.push(node);\n        }\n      });\n\n      for (var i = nodesToRemove_1.length - 1; i >= 0; --i) {\n        rBush.remove(nodesToRemove_1[i]);\n      }\n    }\n\n    if (unregister) {\n      unlistenByKey(this.featureChangeListenerKeys_[feature_uid]);\n      delete this.featureChangeListenerKeys_[feature_uid];\n    }\n  };\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../PluggableMap.js\").default} map Map.\n   */\n\n\n  Snap.prototype.setMap = function (map) {\n    var currentMap = this.getMap();\n    var keys = this.featuresListenerKeys_;\n    var features =\n    /** @type {Array<import(\"../Feature.js\").default>} */\n    this.getFeatures_();\n\n    if (currentMap) {\n      keys.forEach(unlistenByKey);\n      keys.length = 0;\n      features.forEach(this.forEachFeatureRemove_.bind(this));\n    }\n\n    _super.prototype.setMap.call(this, map);\n\n    if (map) {\n      if (this.features_) {\n        keys.push(listen(this.features_, CollectionEventType.ADD, this.handleFeatureAdd_, this), listen(this.features_, CollectionEventType.REMOVE, this.handleFeatureRemove_, this));\n      } else if (this.source_) {\n        keys.push(listen(this.source_, VectorEventType.ADDFEATURE, this.handleFeatureAdd_, this), listen(this.source_, VectorEventType.REMOVEFEATURE, this.handleFeatureRemove_, this));\n      }\n\n      features.forEach(this.forEachFeatureAdd_.bind(this));\n    }\n  };\n  /**\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel\n   * @param {import(\"../coordinate.js\").Coordinate} pixelCoordinate Coordinate\n   * @param {import(\"../PluggableMap.js\").default} map Map.\n   * @return {Result|null} Snap result\n   */\n\n\n  Snap.prototype.snapTo = function (pixel, pixelCoordinate, map) {\n    var lowerLeft = map.getCoordinateFromPixel([pixel[0] - this.pixelTolerance_, pixel[1] + this.pixelTolerance_]);\n    var upperRight = map.getCoordinateFromPixel([pixel[0] + this.pixelTolerance_, pixel[1] - this.pixelTolerance_]);\n    var box = boundingExtent([lowerLeft, upperRight]);\n    var segments = this.rBush_.getInExtent(box);\n    var segmentsLength = segments.length;\n\n    if (segmentsLength === 0) {\n      return null;\n    }\n\n    var projection = map.getView().getProjection();\n    var projectedCoordinate = fromUserCoordinate(pixelCoordinate, projection);\n    var closestVertex;\n    var minSquaredDistance = Infinity;\n    var squaredPixelTolerance = this.pixelTolerance_ * this.pixelTolerance_;\n\n    var getResult = function () {\n      if (closestVertex) {\n        var vertexPixel = map.getPixelFromCoordinate(closestVertex);\n        var squaredPixelDistance = squaredDistance(pixel, vertexPixel);\n\n        if (squaredPixelDistance <= squaredPixelTolerance) {\n          return {\n            vertex: closestVertex,\n            vertexPixel: [Math.round(vertexPixel[0]), Math.round(vertexPixel[1])]\n          };\n        }\n      }\n\n      return null;\n    };\n\n    if (this.vertex_) {\n      for (var i = 0; i < segmentsLength; ++i) {\n        var segmentData = segments[i];\n\n        if (segmentData.feature.getGeometry().getType() !== GeometryType.CIRCLE) {\n          segmentData.segment.forEach(function (vertex) {\n            var tempVertexCoord = fromUserCoordinate(vertex, projection);\n            var delta = squaredDistance(projectedCoordinate, tempVertexCoord);\n\n            if (delta < minSquaredDistance) {\n              closestVertex = vertex;\n              minSquaredDistance = delta;\n            }\n          });\n        }\n      }\n\n      var result = getResult();\n\n      if (result) {\n        return result;\n      }\n    }\n\n    if (this.edge_) {\n      for (var i = 0; i < segmentsLength; ++i) {\n        var vertex = null;\n        var segmentData = segments[i];\n\n        if (segmentData.feature.getGeometry().getType() === GeometryType.CIRCLE) {\n          var circleGeometry = segmentData.feature.getGeometry();\n          var userProjection = getUserProjection();\n\n          if (userProjection) {\n            circleGeometry = circleGeometry.clone().transform(userProjection, projection);\n          }\n\n          vertex = toUserCoordinate(closestOnCircle(projectedCoordinate,\n          /** @type {import(\"../geom/Circle.js\").default} */\n          circleGeometry), projection);\n        } else {\n          var _a = segmentData.segment,\n              segmentStart = _a[0],\n              segmentEnd = _a[1]; // points have only one coordinate\n\n          if (segmentEnd) {\n            tempSegment[0] = fromUserCoordinate(segmentStart, projection);\n            tempSegment[1] = fromUserCoordinate(segmentEnd, projection);\n            vertex = closestOnSegment(projectedCoordinate, tempSegment);\n          }\n        }\n\n        if (vertex) {\n          var delta = squaredDistance(projectedCoordinate, vertex);\n\n          if (delta < minSquaredDistance) {\n            closestVertex = vertex;\n            minSquaredDistance = delta;\n          }\n        }\n      }\n\n      var result = getResult();\n\n      if (result) {\n        return result;\n      }\n    }\n\n    return null;\n  };\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @private\n   */\n\n\n  Snap.prototype.updateFeature_ = function (feature) {\n    this.removeFeature(feature, false);\n    this.addFeature(feature, false);\n  };\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/Circle.js\").default} geometry Geometry.\n   * @private\n   */\n\n\n  Snap.prototype.segmentCircleGemetry_ = function (segments, geometry) {\n    var projection = this.getMap().getView().getProjection();\n    var circleGeometry = geometry;\n    var userProjection = getUserProjection();\n\n    if (userProjection) {\n      circleGeometry =\n      /** @type {import(\"../geom/Circle.js\").default} */\n      circleGeometry.clone().transform(userProjection, projection);\n    }\n\n    var polygon = fromCircle(circleGeometry);\n\n    if (userProjection) {\n      polygon.transform(projection, userProjection);\n    }\n\n    var coordinates = polygon.getCoordinates()[0];\n\n    for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      segments.push(coordinates.slice(i, i + 2));\n    }\n  };\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\n   * @private\n   */\n\n\n  Snap.prototype.segmentGeometryCollectionGemetry_ = function (segments, geometry) {\n    var geometries = geometry.getGeometriesArray();\n\n    for (var i = 0; i < geometries.length; ++i) {\n      var segmenter = this.GEOMETRY_SEGMENTERS_[geometries[i].getType()];\n\n      if (segmenter) {\n        segmenter(segments, geometries[i]);\n      }\n    }\n  };\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/LineString.js\").default} geometry Geometry.\n   * @private\n   */\n\n\n  Snap.prototype.segmentLineStringGemetry_ = function (segments, geometry) {\n    var coordinates = geometry.getCoordinates();\n\n    for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      segments.push(coordinates.slice(i, i + 2));\n    }\n  };\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/MultiLineString.js\").default} geometry Geometry.\n   * @private\n   */\n\n\n  Snap.prototype.segmentMultiLineStringGemetry_ = function (segments, geometry) {\n    var lines = geometry.getCoordinates();\n\n    for (var j = 0, jj = lines.length; j < jj; ++j) {\n      var coordinates = lines[j];\n\n      for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        segments.push(coordinates.slice(i, i + 2));\n      }\n    }\n  };\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/MultiPoint.js\").default} geometry Geometry.\n   * @private\n   */\n\n\n  Snap.prototype.segmentMultiPointGemetry_ = function (segments, geometry) {\n    geometry.getCoordinates().forEach(function (point) {\n      segments.push([point]);\n    });\n  };\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n   * @private\n   */\n\n\n  Snap.prototype.segmentMultiPolygonGemetry_ = function (segments, geometry) {\n    var polygons = geometry.getCoordinates();\n\n    for (var k = 0, kk = polygons.length; k < kk; ++k) {\n      var rings = polygons[k];\n\n      for (var j = 0, jj = rings.length; j < jj; ++j) {\n        var coordinates = rings[j];\n\n        for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n          segments.push(coordinates.slice(i, i + 2));\n        }\n      }\n    }\n  };\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/Point.js\").default} geometry Geometry.\n   * @private\n   */\n\n\n  Snap.prototype.segmentPointGemetry_ = function (segments, geometry) {\n    segments.push([geometry.getCoordinates()]);\n  };\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/Polygon.js\").default} geometry Geometry.\n   * @private\n   */\n\n\n  Snap.prototype.segmentPolygonGemetry_ = function (segments, geometry) {\n    var rings = geometry.getCoordinates();\n\n    for (var j = 0, jj = rings.length; j < jj; ++j) {\n      var coordinates = rings[j];\n\n      for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        segments.push(coordinates.slice(i, i + 2));\n      }\n    }\n  };\n\n  return Snap;\n}(PointerInteraction);\n\nexport default Snap;","map":{"version":3,"mappings":"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","names":["CollectionEventType","EventType","GeometryType","PointerInteraction","RBush","VectorEventType","FALSE","TRUE","boundingExtent","createEmpty","closestOnCircle","closestOnSegment","squaredDistance","fromCircle","fromUserCoordinate","getUserProjection","toUserCoordinate","getUid","getValues","listen","unlistenByKey","getFeatureFromEvent","evt","feature","element","tempSegment","__extends","opt_options","options","pointerOptions","handleDownEvent","stopDown","_super","_this","source_","source","vertex_","vertex","undefined","edge_","edge","features_","features","featuresListenerKeys_","featureChangeListenerKeys_","indexedFeaturesExtents_","pendingFeatures_","pixelTolerance_","pixelTolerance","rBush_","GEOMETRY_SEGMENTERS_","segmentPointGemetry_","bind","segmentLineStringGemetry_","segmentPolygonGemetry_","segmentMultiPointGemetry_","segmentMultiLineStringGemetry_","segmentMultiPolygonGemetry_","segmentGeometryCollectionGemetry_","segmentCircleGemetry_","Snap","opt_listen","register","feature_uid","geometry","getGeometry","segmenter","getType","getExtent","segments","length","insert","segment","extents","map","s","segmentsData","load","CHANGE","handleFeatureChange_","addFeature","removeFeature","getFeatures","result","snapTo","pixel","coordinate","slice","vertexPixel","handleEvent","call","target","handlingDownUpSequence","uid","updateFeature_","featuresToUpdate","forEach","opt_unlisten","unregister","extent","rBush","nodesToRemove_1","forEachInExtent","node","push","i","remove","currentMap","getMap","keys","getFeatures_","forEachFeatureRemove_","setMap","ADD","handleFeatureAdd_","REMOVE","handleFeatureRemove_","ADDFEATURE","REMOVEFEATURE","forEachFeatureAdd_","pixelCoordinate","lowerLeft","getCoordinateFromPixel","upperRight","box","getInExtent","segmentsLength","projection","getView","getProjection","projectedCoordinate","closestVertex","minSquaredDistance","Infinity","squaredPixelTolerance","getResult","getPixelFromCoordinate","squaredPixelDistance","Math","round","segmentData","CIRCLE","tempVertexCoord","delta","circleGeometry","userProjection","clone","transform","segmentStart","segmentEnd","polygon","coordinates","getCoordinates","ii","geometries","getGeometriesArray","lines","j","jj","point","polygons","k","kk","rings"],"sources":["C:\\Users\\GAURA\\comp-4800-team-4\\client\\node_modules\\ol\\src\\interaction\\Snap.js"],"sourcesContent":["/**\n * @module ol/interaction/Snap\n */\nimport CollectionEventType from '../CollectionEventType.js';\nimport EventType from '../events/EventType.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport PointerInteraction from './Pointer.js';\nimport RBush from '../structs/RBush.js';\nimport VectorEventType from '../source/VectorEventType.js';\nimport {FALSE, TRUE} from '../functions.js';\nimport {boundingExtent, createEmpty} from '../extent.js';\nimport {\n  closestOnCircle,\n  closestOnSegment,\n  squaredDistance,\n} from '../coordinate.js';\nimport {fromCircle} from '../geom/Polygon.js';\nimport {\n  fromUserCoordinate,\n  getUserProjection,\n  toUserCoordinate,\n} from '../proj.js';\nimport {getUid} from '../util.js';\nimport {getValues} from '../obj.js';\nimport {listen, unlistenByKey} from '../events.js';\n\n/**\n * @typedef {Object} Result\n * @property {import(\"../coordinate.js\").Coordinate|null} vertex Vertex.\n * @property {import(\"../pixel.js\").Pixel|null} vertexPixel VertexPixel.\n */\n\n/**\n * @typedef {Object} SegmentData\n * @property {import(\"../Feature.js\").default} feature Feature.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} segment Segment.\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../Collection.js\").default<import(\"../Feature.js\").default>} [features] Snap to these features. Either this option or source should be provided.\n * @property {boolean} [edge=true] Snap to edges.\n * @property {boolean} [vertex=true] Snap to vertices.\n * @property {number} [pixelTolerance=10] Pixel tolerance for considering the pointer close enough to a segment or\n * vertex for snapping.\n * @property {import(\"../source/Vector.js\").default} [source] Snap to features from this source. Either this option or features should be provided\n */\n\n/**\n * @param  {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n * @return {import(\"../Feature.js\").default} Feature.\n */\nfunction getFeatureFromEvent(evt) {\n  if (\n    /** @type {import(\"../source/Vector.js\").VectorSourceEvent} */ (evt).feature\n  ) {\n    return /** @type {import(\"../source/Vector.js\").VectorSourceEvent} */ (evt)\n      .feature;\n  } else if (\n    /** @type {import(\"../Collection.js\").CollectionEvent} */ (evt).element\n  ) {\n    return /** @type {import(\"../Feature.js\").default} */ (\n      /** @type {import(\"../Collection.js\").CollectionEvent} */ (evt).element\n    );\n  }\n}\n\nconst tempSegment = [];\n\n/**\n * @classdesc\n * Handles snapping of vector features while modifying or drawing them.  The\n * features can come from a {@link module:ol/source/Vector~VectorSource} or {@link module:ol/Collection~Collection}\n * Any interaction object that allows the user to interact\n * with the features using the mouse can benefit from the snapping, as long\n * as it is added before.\n *\n * The snap interaction modifies map browser event `coordinate` and `pixel`\n * properties to force the snap to occur to any interaction that them.\n *\n * Example:\n *\n *     import Snap from 'ol/interaction/Snap';\n *\n *     const snap = new Snap({\n *       source: source\n *     });\n *\n *     map.addInteraction(snap);\n *\n * @api\n */\nclass Snap extends PointerInteraction {\n  /**\n   * @param {Options} [opt_options] Options.\n   */\n  constructor(opt_options) {\n    const options = opt_options ? opt_options : {};\n\n    const pointerOptions = /** @type {import(\"./Pointer.js\").Options} */ (\n      options\n    );\n\n    if (!pointerOptions.handleDownEvent) {\n      pointerOptions.handleDownEvent = TRUE;\n    }\n\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n\n    super(pointerOptions);\n\n    /**\n     * @type {import(\"../source/Vector.js\").default|null}\n     * @private\n     */\n    this.source_ = options.source ? options.source : null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.vertex_ = options.vertex !== undefined ? options.vertex : true;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.edge_ = options.edge !== undefined ? options.edge : true;\n\n    /**\n     * @type {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|null}\n     * @private\n     */\n    this.features_ = options.features ? options.features : null;\n\n    /**\n     * @type {Array<import(\"../events.js\").EventsKey>}\n     * @private\n     */\n    this.featuresListenerKeys_ = [];\n\n    /**\n     * @type {Object<string, import(\"../events.js\").EventsKey>}\n     * @private\n     */\n    this.featureChangeListenerKeys_ = {};\n\n    /**\n     * Extents are preserved so indexed segment can be quickly removed\n     * when its feature geometry changes\n     * @type {Object<string, import(\"../extent.js\").Extent>}\n     * @private\n     */\n    this.indexedFeaturesExtents_ = {};\n\n    /**\n     * If a feature geometry changes while a pointer drag|move event occurs, the\n     * feature doesn't get updated right away.  It will be at the next 'pointerup'\n     * event fired.\n     * @type {!Object<string, import(\"../Feature.js\").default>}\n     * @private\n     */\n    this.pendingFeatures_ = {};\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.pixelTolerance_ =\n      options.pixelTolerance !== undefined ? options.pixelTolerance : 10;\n\n    /**\n     * Segment RTree for each layer\n     * @type {import(\"../structs/RBush.js\").default<SegmentData>}\n     * @private\n     */\n    this.rBush_ = new RBush();\n\n    /**\n     * @const\n     * @private\n     * @type {Object<string, function(Array<Array<import('../coordinate.js').Coordinate>>, import(\"../geom/Geometry.js\").default): void>}\n     */\n    this.GEOMETRY_SEGMENTERS_ = {\n      'Point': this.segmentPointGemetry_.bind(this),\n      'LineString': this.segmentLineStringGemetry_.bind(this),\n      'LinearRing': this.segmentLineStringGemetry_.bind(this),\n      'Polygon': this.segmentPolygonGemetry_.bind(this),\n      'MultiPoint': this.segmentMultiPointGemetry_.bind(this),\n      'MultiLineString': this.segmentMultiLineStringGemetry_.bind(this),\n      'MultiPolygon': this.segmentMultiPolygonGemetry_.bind(this),\n      'GeometryCollection': this.segmentGeometryCollectionGemetry_.bind(this),\n      'Circle': this.segmentCircleGemetry_.bind(this),\n    };\n  }\n\n  /**\n   * Add a feature to the collection of features that we may snap to.\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {boolean} [opt_listen] Whether to listen to the feature change or not\n   *     Defaults to `true`.\n   * @api\n   */\n  addFeature(feature, opt_listen) {\n    const register = opt_listen !== undefined ? opt_listen : true;\n    const feature_uid = getUid(feature);\n    const geometry = feature.getGeometry();\n    if (geometry) {\n      const segmenter = this.GEOMETRY_SEGMENTERS_[geometry.getType()];\n      if (segmenter) {\n        this.indexedFeaturesExtents_[feature_uid] = geometry.getExtent(\n          createEmpty()\n        );\n        const segments =\n          /** @type {Array<Array<import('../coordinate.js').Coordinate>>} */ ([]);\n        segmenter(segments, geometry);\n        if (segments.length === 1) {\n          this.rBush_.insert(boundingExtent(segments[0]), {\n            feature: feature,\n            segment: segments[0],\n          });\n        } else if (segments.length > 1) {\n          const extents = segments.map((s) => boundingExtent(s));\n          const segmentsData = segments.map((segment) => ({\n            feature: feature,\n            segment: segment,\n          }));\n          this.rBush_.load(extents, segmentsData);\n        }\n      }\n    }\n\n    if (register) {\n      this.featureChangeListenerKeys_[feature_uid] = listen(\n        feature,\n        EventType.CHANGE,\n        this.handleFeatureChange_,\n        this\n      );\n    }\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @private\n   */\n  forEachFeatureAdd_(feature) {\n    this.addFeature(feature);\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @private\n   */\n  forEachFeatureRemove_(feature) {\n    this.removeFeature(feature);\n  }\n\n  /**\n   * @return {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|Array<import(\"../Feature.js\").default>} Features.\n   * @private\n   */\n  getFeatures_() {\n    let features;\n    if (this.features_) {\n      features = this.features_;\n    } else if (this.source_) {\n      features = this.source_.getFeatures();\n    }\n    return features;\n  }\n\n  /**\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   */\n  handleEvent(evt) {\n    const result = this.snapTo(evt.pixel, evt.coordinate, evt.map);\n    if (result) {\n      evt.coordinate = result.vertex.slice(0, 2);\n      evt.pixel = result.vertexPixel;\n    }\n    return super.handleEvent(evt);\n  }\n\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n   * @private\n   */\n  handleFeatureAdd_(evt) {\n    const feature = getFeatureFromEvent(evt);\n    this.addFeature(feature);\n  }\n\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n   * @private\n   */\n  handleFeatureRemove_(evt) {\n    const feature = getFeatureFromEvent(evt);\n    this.removeFeature(feature);\n  }\n\n  /**\n   * @param {import(\"../events/Event.js\").default} evt Event.\n   * @private\n   */\n  handleFeatureChange_(evt) {\n    const feature = /** @type {import(\"../Feature.js\").default} */ (evt.target);\n    if (this.handlingDownUpSequence) {\n      const uid = getUid(feature);\n      if (!(uid in this.pendingFeatures_)) {\n        this.pendingFeatures_[uid] = feature;\n      }\n    } else {\n      this.updateFeature_(feature);\n    }\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleUpEvent(evt) {\n    const featuresToUpdate = getValues(this.pendingFeatures_);\n    if (featuresToUpdate.length) {\n      featuresToUpdate.forEach(this.updateFeature_.bind(this));\n      this.pendingFeatures_ = {};\n    }\n    return false;\n  }\n\n  /**\n   * Remove a feature from the collection of features that we may snap to.\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {boolean} [opt_unlisten] Whether to unlisten to the feature change\n   *     or not. Defaults to `true`.\n   * @api\n   */\n  removeFeature(feature, opt_unlisten) {\n    const unregister = opt_unlisten !== undefined ? opt_unlisten : true;\n    const feature_uid = getUid(feature);\n    const extent = this.indexedFeaturesExtents_[feature_uid];\n    if (extent) {\n      const rBush = this.rBush_;\n      const nodesToRemove = [];\n      rBush.forEachInExtent(extent, function (node) {\n        if (feature === node.feature) {\n          nodesToRemove.push(node);\n        }\n      });\n      for (let i = nodesToRemove.length - 1; i >= 0; --i) {\n        rBush.remove(nodesToRemove[i]);\n      }\n    }\n\n    if (unregister) {\n      unlistenByKey(this.featureChangeListenerKeys_[feature_uid]);\n      delete this.featureChangeListenerKeys_[feature_uid];\n    }\n  }\n\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../PluggableMap.js\").default} map Map.\n   */\n  setMap(map) {\n    const currentMap = this.getMap();\n    const keys = this.featuresListenerKeys_;\n    const features = /** @type {Array<import(\"../Feature.js\").default>} */ (\n      this.getFeatures_()\n    );\n\n    if (currentMap) {\n      keys.forEach(unlistenByKey);\n      keys.length = 0;\n      features.forEach(this.forEachFeatureRemove_.bind(this));\n    }\n    super.setMap(map);\n\n    if (map) {\n      if (this.features_) {\n        keys.push(\n          listen(\n            this.features_,\n            CollectionEventType.ADD,\n            this.handleFeatureAdd_,\n            this\n          ),\n          listen(\n            this.features_,\n            CollectionEventType.REMOVE,\n            this.handleFeatureRemove_,\n            this\n          )\n        );\n      } else if (this.source_) {\n        keys.push(\n          listen(\n            this.source_,\n            VectorEventType.ADDFEATURE,\n            this.handleFeatureAdd_,\n            this\n          ),\n          listen(\n            this.source_,\n            VectorEventType.REMOVEFEATURE,\n            this.handleFeatureRemove_,\n            this\n          )\n        );\n      }\n      features.forEach(this.forEachFeatureAdd_.bind(this));\n    }\n  }\n\n  /**\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel\n   * @param {import(\"../coordinate.js\").Coordinate} pixelCoordinate Coordinate\n   * @param {import(\"../PluggableMap.js\").default} map Map.\n   * @return {Result|null} Snap result\n   */\n  snapTo(pixel, pixelCoordinate, map) {\n    const lowerLeft = map.getCoordinateFromPixel([\n      pixel[0] - this.pixelTolerance_,\n      pixel[1] + this.pixelTolerance_,\n    ]);\n    const upperRight = map.getCoordinateFromPixel([\n      pixel[0] + this.pixelTolerance_,\n      pixel[1] - this.pixelTolerance_,\n    ]);\n    const box = boundingExtent([lowerLeft, upperRight]);\n\n    const segments = this.rBush_.getInExtent(box);\n\n    const segmentsLength = segments.length;\n    if (segmentsLength === 0) {\n      return null;\n    }\n\n    const projection = map.getView().getProjection();\n    const projectedCoordinate = fromUserCoordinate(pixelCoordinate, projection);\n\n    let closestVertex;\n    let minSquaredDistance = Infinity;\n\n    const squaredPixelTolerance = this.pixelTolerance_ * this.pixelTolerance_;\n    const getResult = () => {\n      if (closestVertex) {\n        const vertexPixel = map.getPixelFromCoordinate(closestVertex);\n        const squaredPixelDistance = squaredDistance(pixel, vertexPixel);\n        if (squaredPixelDistance <= squaredPixelTolerance) {\n          return {\n            vertex: closestVertex,\n            vertexPixel: [\n              Math.round(vertexPixel[0]),\n              Math.round(vertexPixel[1]),\n            ],\n          };\n        }\n      }\n      return null;\n    };\n\n    if (this.vertex_) {\n      for (let i = 0; i < segmentsLength; ++i) {\n        const segmentData = segments[i];\n        if (\n          segmentData.feature.getGeometry().getType() !== GeometryType.CIRCLE\n        ) {\n          segmentData.segment.forEach((vertex) => {\n            const tempVertexCoord = fromUserCoordinate(vertex, projection);\n            const delta = squaredDistance(projectedCoordinate, tempVertexCoord);\n            if (delta < minSquaredDistance) {\n              closestVertex = vertex;\n              minSquaredDistance = delta;\n            }\n          });\n        }\n      }\n      const result = getResult();\n      if (result) {\n        return result;\n      }\n    }\n\n    if (this.edge_) {\n      for (let i = 0; i < segmentsLength; ++i) {\n        let vertex = null;\n        const segmentData = segments[i];\n        if (\n          segmentData.feature.getGeometry().getType() === GeometryType.CIRCLE\n        ) {\n          let circleGeometry = segmentData.feature.getGeometry();\n          const userProjection = getUserProjection();\n          if (userProjection) {\n            circleGeometry = circleGeometry\n              .clone()\n              .transform(userProjection, projection);\n          }\n          vertex = toUserCoordinate(\n            closestOnCircle(\n              projectedCoordinate,\n              /** @type {import(\"../geom/Circle.js\").default} */ (\n                circleGeometry\n              )\n            ),\n            projection\n          );\n        } else {\n          const [segmentStart, segmentEnd] = segmentData.segment;\n          // points have only one coordinate\n          if (segmentEnd) {\n            tempSegment[0] = fromUserCoordinate(segmentStart, projection);\n            tempSegment[1] = fromUserCoordinate(segmentEnd, projection);\n            vertex = closestOnSegment(projectedCoordinate, tempSegment);\n          }\n        }\n        if (vertex) {\n          const delta = squaredDistance(projectedCoordinate, vertex);\n          if (delta < minSquaredDistance) {\n            closestVertex = vertex;\n            minSquaredDistance = delta;\n          }\n        }\n      }\n\n      const result = getResult();\n      if (result) {\n        return result;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @private\n   */\n  updateFeature_(feature) {\n    this.removeFeature(feature, false);\n    this.addFeature(feature, false);\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/Circle.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentCircleGemetry_(segments, geometry) {\n    const projection = this.getMap().getView().getProjection();\n    let circleGeometry = geometry;\n    const userProjection = getUserProjection();\n    if (userProjection) {\n      circleGeometry = /** @type {import(\"../geom/Circle.js\").default} */ (\n        circleGeometry.clone().transform(userProjection, projection)\n      );\n    }\n    const polygon = fromCircle(circleGeometry);\n    if (userProjection) {\n      polygon.transform(projection, userProjection);\n    }\n    const coordinates = polygon.getCoordinates()[0];\n    for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      segments.push(coordinates.slice(i, i + 2));\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentGeometryCollectionGemetry_(segments, geometry) {\n    const geometries = geometry.getGeometriesArray();\n    for (let i = 0; i < geometries.length; ++i) {\n      const segmenter = this.GEOMETRY_SEGMENTERS_[geometries[i].getType()];\n      if (segmenter) {\n        segmenter(segments, geometries[i]);\n      }\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/LineString.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentLineStringGemetry_(segments, geometry) {\n    const coordinates = geometry.getCoordinates();\n    for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      segments.push(coordinates.slice(i, i + 2));\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/MultiLineString.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentMultiLineStringGemetry_(segments, geometry) {\n    const lines = geometry.getCoordinates();\n    for (let j = 0, jj = lines.length; j < jj; ++j) {\n      const coordinates = lines[j];\n      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        segments.push(coordinates.slice(i, i + 2));\n      }\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/MultiPoint.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentMultiPointGemetry_(segments, geometry) {\n    geometry.getCoordinates().forEach((point) => {\n      segments.push([point]);\n    });\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentMultiPolygonGemetry_(segments, geometry) {\n    const polygons = geometry.getCoordinates();\n    for (let k = 0, kk = polygons.length; k < kk; ++k) {\n      const rings = polygons[k];\n      for (let j = 0, jj = rings.length; j < jj; ++j) {\n        const coordinates = rings[j];\n        for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n          segments.push(coordinates.slice(i, i + 2));\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/Point.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentPointGemetry_(segments, geometry) {\n    segments.push([geometry.getCoordinates()]);\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/Polygon.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentPolygonGemetry_(segments, geometry) {\n    const rings = geometry.getCoordinates();\n    for (let j = 0, jj = rings.length; j < jj; ++j) {\n      const coordinates = rings[j];\n      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        segments.push(coordinates.slice(i, i + 2));\n      }\n    }\n  }\n}\n\nexport default Snap;\n"]},"metadata":{},"sourceType":"module"}